//-----------------------------------------------------------------------------
// framework.c
// Author:	Ariel Jaffe
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// Includes
//-----------------------------------------------------------------------------
#include "framework.h"


//-----------------------------------------------------------------------------
// DEFINES
//-----------------------------------------------------------------------------
#define RDATA				0x20	// R/XDATA interrupt mask
#define XDATA				0x20
#define I2C_PORT_AIC3106	(I2C0)


//-----------------------------------------------------------------------------
// Private Defines and Macros
//-----------------------------------------------------------------------------
// pinmux defines.
#define PINMUX_MCASP_REG_0       (0)
#define PINMUX_MCASP_MASK_0      (0x00FFFFFF)
#define PINMUX_MCASP_VAL_0       (0x00111111)
#define PINMUX_MCASP_REG_1       (1)
#define PINMUX_MCASP_MASK_1      (0x000FF000)
#define PINMUX_MCASP_VAL_1       (0x00011000)


//-----------------------------------------------------------------------------
//read_audio_sample()
//-----------------------------------------------------------------------------
int16_t read_audio_sample()
{
	int16_t s;
	s = (int16_t)(MCASP->XBUF12);
	return s;
}


//-----------------------------------------------------------------------------
//write_audio_sample()
//-----------------------------------------------------------------------------
void write_audio_sample(int16_t s)
{
	MCASP->XBUF11 = (uint32_t)s;
}


//-----------------------------------------------------------------------------
//initAll()
//-----------------------------------------------------------------------------
void initAll(void)
{
	I2C_init(I2C0, I2C_CLK_400K);	// init I2C channel

	SetGpio();

	LED_init();						// init LED and DIP BSL
	DIP_init();
	McASP_Init();					// init McASP (modified from original BSL)
	AIC3106_Init();					// init AIC3106 (modified from original BSL)

	ICR  = (1 << 5);				// clear INT5 (precaution)
	IER |= (1 << 5);				// enable INT5 as CPU interrupt
	IER |= (1 << 11);				// enable RTDX interrupts
	IER |= (1 << 12);				// enable RTDX interrupts

	McASP_Start();					// start McASP clocks
}


//-----------------------------------------------------------------------------
// McASP_Init()
//-----------------------------------------------------------------------------
void McASP_Init(void)
{
	// enable the psc and config pinmux for mcasp.
	EVMC6748_lpscTransition(PSC1, DOMAIN0, LPSC_MCASP0, PSC_ENABLE);
	EVMC6748_pinmuxConfig(PINMUX_MCASP_REG_0, PINMUX_MCASP_MASK_0, PINMUX_MCASP_VAL_0);
	EVMC6748_pinmuxConfig(PINMUX_MCASP_REG_1, PINMUX_MCASP_MASK_1, PINMUX_MCASP_VAL_1);

	// reset mcasp.
	MCASP->GBLCTL  = 0;

	// NOTE: ROR 16-bits enabled for both XMT/RCV. SLOT SIZE = 16 bits, 1-bit delay for Rx
	// clock and frame sync generated by AIC3106. Tx and Rx synchronized

	// configure receive registers for I2S
	MCASP->RMASK      = 0xFFFFFFFF;		// all 32-bits NOT masked
	MCASP->RFMT       = 0x0001807C;		// MSB first, align left, slot=16bits, 1-bit delay, ROR 16-bits
	MCASP->AFSRCTL    = 0x00000100;		// frame sync generated externally, FS/word, 2 SLOT TDM = I2S
	MCASP->RTDM       = 0x00000003;		// SLOT 0 & 1 active I2S
	MCASP->RINTCTL    = 0x00000000;		// ints disabled
	MCASP->RCLKCHK    = 0x00ff0008;		// RMAX = FF, RPS = /256

	// configure transmit registers for I2S
	MCASP->XMASK      = 0xFFFFFFFF;		// all 32-bits NOT masked
	MCASP->XFMT       = 0x0000807C;		// MSB first, align left, slot=16bits, no delay, ROR 16-bits
	MCASP->AFSXCTL    = 0x00000100;		// frame sync generated externally, FS/word, 2 SLOT TDM = I2S
	MCASP->XTDM       = 0x00000003;		// SLOT 0 & 1 active I2S
	MCASP->XINTCTL    = 0x00000000;		// ints disabled
	MCASP->XCLKCHK    = 0x00ff0008;		// RMAX = FF, RPS = /256

	//configure clock operation
	MCASP->ACLKRCTL   = 0x00000000;
	MCASP->AHCLKRCTL  = 0x00000000;
	MCASP->ACLKXCTL   = 0x00000000;		//rising edge, clkrm external sync between Tx and Rx clocks
	MCASP->AHCLKXCTL  = 0x00000000;

	// config serializers (11 = xmit, 12 = rcv)
	MCASP->SRCTL11    = 0x000D;			// XMT
	MCASP->SRCTL12    = 0x000E;			// RCV

	// config pin function and direction.
	MCASP->PFUNC      = 0;
	MCASP->PDIR       = 0x00000800;	//ACLKX and AFSX are input pins

	MCASP->DITCTL     = 0x00000000;
	MCASP->DLBCTL     = 0x00000000;
	MCASP->AMUTE      = 0x00000000;
}


//-----------------------------------------------------------------------------
// McASP_Start_TTO()
//-----------------------------------------------------------------------------
void McASP_Start(void)
{
	// enable the audio clocks, verifying each bit is properly set.
	SETBIT(MCASP->XGBLCTL, XHCLKRST);
	while (!CHKBIT(MCASP->XGBLCTL, XHCLKRST)) {}
	SETBIT(MCASP->RGBLCTL, RHCLKRST);
	while (!CHKBIT(MCASP->RGBLCTL, RHCLKRST)) {}

	SETBIT(MCASP->XGBLCTL, XCLKRST);
	while (!CHKBIT(MCASP->XGBLCTL, XCLKRST)) {}
	SETBIT(MCASP->RGBLCTL, RCLKRST);
	while (!CHKBIT(MCASP->RGBLCTL, RCLKRST)) {}

	SETBIT(MCASP->RINTCTL, RDATA);					// enable McASP XMT/RCV interrupts
	while (!CHKBIT(MCASP->RINTCTL, RDATA)) {}		// see #defines at top of file
/*
	SETBIT(MCASP->XINTCTL, XDATA);
	while (!CHKBIT(MCASP->XINTCTL, XDATA)) {}
*/
	MCASP->XSTAT = 0x0000FFFF;        // Clear all (see procedure in UG)
	MCASP->RSTAT = 0x0000FFFF;        // Clear all

	SETBIT(MCASP->XGBLCTL, XSRCLR);
	while (!CHKBIT(MCASP->XGBLCTL, XSRCLR)) {}
	SETBIT(MCASP->RGBLCTL, RSRCLR);
	while (!CHKBIT(MCASP->RGBLCTL, RSRCLR)) {}

	/* Write a 0, so that no underrun occurs after releasing the state machine */
	MCASP->XBUF11 = 0;

	SETBIT(MCASP->XGBLCTL, XSMRST);
	while (!CHKBIT(MCASP->XGBLCTL, XSMRST)) {}
	SETBIT(MCASP->RGBLCTL, RSMRST);
	while (!CHKBIT(MCASP->RGBLCTL, RSMRST)) {}

	SETBIT(MCASP->XGBLCTL, XFRST);
	while (!CHKBIT(MCASP->XGBLCTL, XFRST)) {}
	SETBIT(MCASP->RGBLCTL, RFRST);
	while (!CHKBIT(MCASP->RGBLCTL, RFRST)) {}

	// wait for transmit ready and send a dummy byte.
	while(!CHKBIT(MCASP->SRCTL11, XRDY)) {}
	MCASP->XBUF11 = 0;
}


//-----------------------------------------------------------------------------
// AIC3106_Init()
//-----------------------------------------------------------------------------
void AIC3106_Init(void)
{
	// select page 0 and reset codec.
	AIC3106_writeRegister(AIC3106_REG_PAGESELECT, 0);
	AIC3106_writeRegister(AIC3106_REG_RESET, 0x80);

	// config codec regs. please see AIC3106 documentation for explanation.
	// Document Num: TLV320AIC3106

#ifdef FS_48KHZ		// 48kHz sampling rate
		AIC3106_writeRegister(3,
				(0 << 7) |	// PLL is disabled
				(4 << 3) |	// PLL Q value = 4
				(2 << 0));	// PLL P value = 2
				//0x22);	// PLL disabled, Q=4, P=2
		AIC3106_writeRegister(2,
				(0 << 4) | 	// ADC fs = fs(ref)/1
				(0 << 0));	// DAC fs = fs(ref)/1
				//0x00);	//ADC/DAC sample rate = f(s)/1 = MCLK/(128*Q)/1
#endif

#ifdef FS_8KHZ
		AIC3106_writeRegister(3,
				(0 << 7) |	// PLL is disabled
				(4 << 3) |	// PLL Q value = 4
				(2 << 0));	// PLL P value = 2
		//AIC3106_writeRegister(3, 0x22);	// PLL disabled, Q=4, P=2

		AIC3106_writeRegister(2,
				(10 << 4) | 	// ADC fs = fs(ref)/6
				(10 << 0));	// DAC fs = fs(ref)/6
		//AIC3106_writeRegister(2, 0xAA);	//ADC/DAC sample rate = f(s)/6 = MCLK/(128*Q)/6
#endif

#ifdef FS_10KHZ	//  9.6kHz
		AIC3106_writeRegister(3,
				(0 << 7) |	// PLL is disabled
				(10 << 3) |	// PLL Q value = 10
				(2 << 0));	// PLL P value = 2
		//AIC3106_writeRegister(3, (0 << 7) | (10 << 3) | (2 << 0));	// PLL disabled, Q=10, P=2

		AIC3106_writeRegister(2,
				(2 << 4) | 	// ADC fs = fs(ref)/6
				(2 << 0));	// DAC fs = fs(ref)/6
		//AIC3106_writeRegister(2, 0x22);	//ADC/DAC sample rate = f(s)/2 = MCLK/(128*Q)/2
#endif

#ifdef FS_24KHZ
		AIC3106_writeRegister(3,
				(0 << 7) |	// PLL is disabled
				(4 << 3) |	// PLL Q value = 4
				(2 << 0));	// PLL P value = 2
				//0x22);	// PLL disabled, Q=4, P=2
		AIC3106_writeRegister(2,
				(2 << 4) | 	// ADC fs = fs(ref)/1
				(2 << 0));	// DAC fs = fs(ref)/1
				//0x00);	//ADC/DAC sample rate = f(s)/1 = MCLK/(128*Q)/1
#endif

	AIC3106_writeRegister(7,
				(1 << 7) |	// fs(ref) = 48kHz (needed only for AGC time constants, not used)
				(0 << 6) |	// ADC dual rate mode is disabled
				(0 << 5) |	// DAC dual rate mode is disabled
				(1 << 3) |	// left DAC datapath plays left channel input data
				(1 << 1) |	// right DAC datapath plays right channel input data
				(0 << 0));	// reserved
				//0x0A);

	AIC3106_writeRegister(8,
				(1 << 7) |	// BCLK is input (use "1" for output)
				(1 << 6) |	// WCLK is input (use "1" for output)
				(0 << 5) |	// do no place DOUT in high-z when inactive
				(0 << 4) |	// BCLK & WCLK disabled in master mode if code powered down
				(0 << 3) |	// reserved
				(0 << 2) |	// disable 3D effect
				(0 << 0));	// digital mic support disabled
				//0xC0);	// BCLK and WCLK are output

	AIC3106_writeRegister(9,
				(0 << 6) |	// serial data bus in i2s mode
				(0 << 4) |	// audio word length 16 bits
				(0 << 3) |	// continuous transfer mode
				(0 << 2) |	// don't resync DAC w/ group delay variation
				(0 << 1) |	// don't resync ADC w/ group delay variation
				(0 << 0));	// resync w/o soft muting
				//0x00);	// I2S mode, 32-bit data words, continous xfer mode

	//AIC3106_writeRegister(10, 0x00);		// data word offset

	#if 1	// turn input gain off
	// PGA setting, 0 means 0dB gain
	AIC3106_writeRegister(15,
				(0 << 7) |	// left ADC PGA is not muted
				(0 << 0)); 	// left ADC PGA gain setting = 0 dB
				//(0);

	AIC3106_writeRegister(16,
				(0 << 7) |	// right ADC PGA is not muted
				(0 << 0)); 	// right ADC PGA gain setting = 0 dB
				//(0);

	#else		// turn input gain on
	AIC3106_writeRegister(15,
				(0 << 7) |	// left ADC PGA is not muted
				(44 << 0)); 	// left ADC PGA gain setting = 22 dB
				//(0);

	AIC3106_writeRegister(16,
				(0 << 7) |	// right ADC PGA is not muted
				(44 << 0)); 	// right ADC PGA gain setting = 22 dB
	#endif

	AIC3106_writeRegister(19, 0x04);	// left ADC is powered up
	AIC3106_writeRegister(22, 0x04);	// right ADC is powered up

	AIC3106_writeRegister(27, 0);	// left AGC maximum gain allowed is 0dB (AGC not used)
	AIC3106_writeRegister(30, 0);	// right AGC maximum gain allowed is 0dB (AGC not used)

	AIC3106_writeRegister(37,
				(1 << 7) |	// left DAC powered up
				(1 << 6) |	// right DAC powered up
				(2 << 4) |	// HPLCOM configured as independent single-ended output (not used here)
				(0 << 0));	// reserved
				//0xE0);

	// set the DAC gain
	AIC3106_writeRegister(43,
				(0 << 7) |	// left DAC channel is not muted
				(0 << 0));		// left DAC gain setting = 0dB

	AIC3106_writeRegister(44,
				(0 << 7) |	// right DAC channel is not muted
				(0 << 0));		// left DAC gain setting = 0dB

	#if 0
	// set the DAC gain
	AIC3106_writeRegister(43,
				(0 << 7) |	// left DAC channel is not muted
				(0x28 << 0));		// left DAC gain setting = -20dB

	AIC3106_writeRegister(44,
				(0 << 7) |	// right DAC channel is not muted
				(0x28 << 0));		// left DAC gain setting = -20dB
	#endif

	AIC3106_writeRegister(82,
				(1 << 7) |	// DAC_L1 is routed to LEFT_LOP/M
				(0 << 0));	// DAC_L1 to LEFT_LOP/M analog volum control
				//0x80);
	AIC3106_writeRegister(86,
				(0 << 4) |	// LEFT_LOP/M output level control = 0dB
				(1 << 3) | 	// LEFT_LOP/M is not muted
				(0 << 2) | 	// reserved, read only
				(0 << 1) |	// read only
				(1 << 0));	// read only (must write 1 for some reason)
				// 0x09);

	AIC3106_writeRegister(92,
				(1 << 7) |	// DAC_R1 is routed to RIGHT_LOP/M
				(0 << 0));	// DAC_R1 to RIGHT_LOP/M analog volum control
				//0x80);

	AIC3106_writeRegister(93,
				(0 << 4) |	// RIGHT_LOP/M output level control = 0dB
				(1 << 3) | 	// RIGHT_LOP/M is not muted
				(0 << 2) | 	// reserved, read only
				(0 << 1) |	// read only
				(1 << 0));	// read only (must write 1 for some reason)
				// 0x09);

	AIC3106_writeRegister(101,
				(0 << 6) |	// read only
				(0 << 5) |	// MFP3 pin as GPI disabled
				(0 << 3) |	// read only
				(0 << 2) |	// MFP2 pin as GPO disabled
				(0 << 1) |	// MFP2 drives low when configured as GPO
				(1 << 0));	// CODEC_CLKIN uses CLKDIV_OUT
				//0x01);

	AIC3106_writeRegister(102,
				(0 << 6) |	// CLKDIV_IN uses MCLK
				(0 << 4) |	// PLLCLK_IN uses MCLK
				(0 << 0));	// PLL clock divider N = 16
				//0);	// CLKDIV_IN uses MCLK
}


//-----------------------------------------------------------------------------
// /brief Read data from a register on the AIC3106.
//
// /param uint8_t in_reg_addr: The address of the register to be read from.
//
// /param uint8_t * dest_buffer: Pointer to buffer to store retrieved data.
//
// /return uint32_t ERR_NO_ERROR on sucess
//
//-----------------------------------------------------------------------------
uint32_t AIC3106_readRegister(uint8_t in_reg_addr, uint8_t *dest_buffer)
{
	uint32_t rtn;

	// write the register address that we want to read.
	rtn = I2C_write(I2C_PORT_AIC3106, I2C_ADDR_AIC3106, &in_reg_addr, 1, SKIP_STOP_BIT_AFTER_WRITE);
	if (rtn != ERR_NO_ERROR)
		return (rtn);

	// clock out the register data.
	rtn = I2C_read(I2C_PORT_AIC3106, I2C_ADDR_AIC3106, dest_buffer, 1, SKIP_BUSY_BIT_CHECK);

	return (rtn);
}


//-----------------------------------------------------------------------------
// /brief Write a register on the AIC3106.
//
// /param uint8_t in_reg_addr: The address of the register to be written to.
//
// /param uint8_t data: Data to be written to the register
//
// /return uint32_t ERR_NO_ERROR on sucess
//
//-----------------------------------------------------------------------------
uint32_t AIC3106_writeRegister(uint8_t in_reg_addr, uint8_t in_data)
{
	uint32_t rtn;
	uint8_t i2c_data[2];

	i2c_data[0] = in_reg_addr;
	i2c_data[1] = in_data;

	// write the register that we want to read.
	rtn = I2C_write(I2C_PORT_AIC3106, I2C_ADDR_AIC3106, i2c_data, 2, SET_STOP_BIT_AFTER_WRITE);

	return (rtn);
}


//-----------------------------------------------------------------------------
// USTIMER_delay()
//
// LogicPD BSL fxn - re-written for a few BSL.c files that need it.
// The original USTIMER_init() is not used because it is NOT BIOS compatible
// and took both timers so that BIOS PRDs would not work. This is a
// workaround.
//
// If you need a "delay" in this app, call this routine with the number
// of usec's of delay you need. It is approximate - not exact.
// value for time<300 is perfect for 1us. We padded it some.
//-----------------------------------------------------------------------------
void USTIMER_delay(uint32_t usec)
{
	volatile LgUns i, start, time, current;

	for (i=0; i<usec; i++)
	{
		start = CLK_gethtime();
		time = 0;
		while (time < 350)
		{
			current = CLK_gethtime();
			time = current - start;
		}
	}
}


//-----------------------------------------------------------------------------
// SetGpio
// config pinmux for gpio
//-----------------------------------------------------------------------------
void SetGpio(void)
{
	EVMC6748_pinmuxConfig(PINMUX_MCASP_REG_17,PINMUX_MCASP_MASK_17,PINMUX_MCASP_VAL_17);
	GPIO_setDir(GPIO_BANK7,GPIO_PIN7,GPIO_OUTPUT);
}

